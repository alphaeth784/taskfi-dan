import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from './auth'\nimport { rateLimits } from './rate-limit'\nimport { handleApiError, AuthenticationError, AuthorizationError } from './error-handler'\nimport { z } from 'zod'\n\n// Security headers\nexport const securityHeaders = {\n  'X-Frame-Options': 'DENY',\n  'X-Content-Type-Options': 'nosniff',\n  'X-XSS-Protection': '1; mode=block',\n  'Referrer-Policy': 'strict-origin-when-cross-origin',\n  'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',\n  'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:;\",\n}\n\n// CORS headers\nexport const corsHeaders = {\n  'Access-Control-Allow-Origin': process.env.NODE_ENV === 'production' \n    ? 'https://your-domain.com' \n    : '*',\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',\n  'Access-Control-Max-Age': '86400', // 24 hours\n}\n\n// Role-based permissions\nexport enum Permission {\n  // User permissions\n  READ_PROFILE = 'read:profile',\n  UPDATE_PROFILE = 'update:profile',\n  DELETE_PROFILE = 'delete:profile',\n  \n  // Job permissions\n  CREATE_JOB = 'create:job',\n  READ_JOB = 'read:job',\n  UPDATE_JOB = 'update:job',\n  DELETE_JOB = 'delete:job',\n  APPLY_JOB = 'apply:job',\n  \n  // Gig permissions\n  CREATE_GIG = 'create:gig',\n  READ_GIG = 'read:gig',\n  UPDATE_GIG = 'update:gig',\n  DELETE_GIG = 'delete:gig',\n  PURCHASE_GIG = 'purchase:gig',\n  \n  // Payment permissions\n  CREATE_PAYMENT = 'create:payment',\n  READ_PAYMENT = 'read:payment',\n  RELEASE_PAYMENT = 'release:payment',\n  DISPUTE_PAYMENT = 'dispute:payment',\n  \n  // Message permissions\n  SEND_MESSAGE = 'send:message',\n  READ_MESSAGE = 'read:message',\n  \n  // Admin permissions\n  ADMIN_USERS = 'admin:users',\n  ADMIN_JOBS = 'admin:jobs',\n  ADMIN_PAYMENTS = 'admin:payments',\n  ADMIN_ANALYTICS = 'admin:analytics',\n  ADMIN_CATEGORIES = 'admin:categories',\n}\n\n// Role to permissions mapping\nconst rolePermissions: Record<string, Permission[]> = {\n  FREELANCER: [\n    Permission.READ_PROFILE,\n    Permission.UPDATE_PROFILE,\n    Permission.READ_JOB,\n    Permission.APPLY_JOB,\n    Permission.CREATE_GIG,\n    Permission.READ_GIG,\n    Permission.UPDATE_GIG,\n    Permission.DELETE_GIG,\n    Permission.READ_PAYMENT,\n    Permission.DISPUTE_PAYMENT,\n    Permission.SEND_MESSAGE,\n    Permission.READ_MESSAGE,\n  ],\n  HIRER: [\n    Permission.READ_PROFILE,\n    Permission.UPDATE_PROFILE,\n    Permission.CREATE_JOB,\n    Permission.READ_JOB,\n    Permission.UPDATE_JOB,\n    Permission.DELETE_JOB,\n    Permission.READ_GIG,\n    Permission.PURCHASE_GIG,\n    Permission.CREATE_PAYMENT,\n    Permission.READ_PAYMENT,\n    Permission.RELEASE_PAYMENT,\n    Permission.DISPUTE_PAYMENT,\n    Permission.SEND_MESSAGE,\n    Permission.READ_MESSAGE,\n  ],\n  ADMIN: Object.values(Permission), // Admin has all permissions\n}\n\n// Check if user has permission\nexport function hasPermission(userRole: string, permission: Permission): boolean {\n  const permissions = rolePermissions[userRole] || []\n  return permissions.includes(permission)\n}\n\n// Security middleware configuration\nexport interface SecurityConfig {\n  requireAuth?: boolean\n  permissions?: Permission[]\n  rateLimitType?: 'api' | 'auth' | 'upload' | 'admin'\n  validateInput?: z.ZodSchema\n  allowedMethods?: string[]\n  skipCors?: boolean\n}\n\n// Main security middleware\nexport function withSecurity(config: SecurityConfig = {}) {\n  return function securityMiddleware(\n    handler: (request: NextRequest, context?: any) => Promise<NextResponse>\n  ) {\n    return async (request: NextRequest, context?: any) => {\n      try {\n        // Handle OPTIONS request for CORS\n        if (request.method === 'OPTIONS') {\n          return new NextResponse(null, {\n            status: 200,\n            headers: {\n              ...corsHeaders,\n              ...securityHeaders,\n            },\n          })\n        }\n\n        // Check allowed methods\n        if (config.allowedMethods && !config.allowedMethods.includes(request.method)) {\n          return NextResponse.json(\n            { error: 'Method not allowed' },\n            { \n              status: 405,\n              headers: {\n                'Allow': config.allowedMethods.join(', '),\n                ...securityHeaders,\n              }\n            }\n          )\n        }\n\n        // Apply rate limiting\n        if (config.rateLimitType) {\n          const rateLimiter = rateLimits[config.rateLimitType]\n          const rateLimitResponse = await rateLimiter(request)\n          if (rateLimitResponse) {\n            return rateLimitResponse\n          }\n        }\n\n        // Authentication check\n        let session = null\n        if (config.requireAuth) {\n          session = await getServerSession(authOptions)\n          if (!session || !session.user) {\n            throw new AuthenticationError('Authentication required')\n          }\n        }\n\n        // Authorization check\n        if (config.permissions && config.permissions.length > 0 && session) {\n          const userRole = session.user.role\n          const hasRequiredPermission = config.permissions.some(permission => \n            hasPermission(userRole, permission)\n          )\n          \n          if (!hasRequiredPermission) {\n            throw new AuthorizationError('Insufficient permissions for this action')\n          }\n        }\n\n        // Input validation\n        if (config.validateInput && ['POST', 'PUT', 'PATCH'].includes(request.method)) {\n          try {\n            const body = await request.json()\n            config.validateInput.parse(body)\n          } catch (error) {\n            if (error instanceof z.ZodError) {\n              return NextResponse.json(\n                {\n                  error: 'Validation error',\n                  details: error.errors.map(err => ({\n                    field: err.path.join('.'),\n                    message: err.message,\n                  })),\n                },\n                { status: 400, headers: securityHeaders }\n              )\n            }\n            throw error\n          }\n        }\n\n        // Execute the actual handler\n        const response = await handler(request, context)\n\n        // Add security headers to response\n        Object.entries(securityHeaders).forEach(([key, value]) => {\n          response.headers.set(key, value)\n        })\n\n        // Add CORS headers if not skipped\n        if (!config.skipCors) {\n          Object.entries(corsHeaders).forEach(([key, value]) => {\n            response.headers.set(key, value)\n          })\n        }\n\n        return response\n      } catch (error) {\n        return handleApiError(error, request)\n      }\n    }\n  }\n}\n\n// Specific middleware functions for common patterns\nexport const requireAuth = withSecurity({ requireAuth: true })\n\nexport const requireAdmin = withSecurity({\n  requireAuth: true,\n  permissions: [Permission.ADMIN_USERS],\n  rateLimitType: 'admin',\n})\n\nexport const requireFreelancer = withSecurity({\n  requireAuth: true,\n  permissions: [Permission.CREATE_GIG],\n  rateLimitType: 'api',\n})\n\nexport const requireHirer = withSecurity({\n  requireAuth: true,\n  permissions: [Permission.CREATE_JOB],\n  rateLimitType: 'api',\n})\n\nexport const withUploadSecurity = withSecurity({\n  requireAuth: true,\n  rateLimitType: 'upload',\n  allowedMethods: ['POST'],\n})\n\nexport const withAuthSecurity = withSecurity({\n  rateLimitType: 'auth',\n  allowedMethods: ['POST'],\n})\n\n// Resource ownership check\nexport async function checkResourceOwnership(\n  request: NextRequest,\n  resourceType: 'job' | 'gig' | 'message' | 'payment',\n  resourceId: string,\n  allowAdmin: boolean = true\n): Promise<boolean> {\n  const session = await getServerSession(authOptions)\n  if (!session) return false\n\n  const userId = session.user.id\n  const userRole = session.user.role\n\n  // Admin bypass\n  if (allowAdmin && userRole === 'ADMIN') {\n    return true\n  }\n\n  // Check ownership based on resource type\n  // This would typically query the database to check ownership\n  // For now, we'll implement basic checks\n  try {\n    switch (resourceType) {\n      case 'job':\n        // Check if user is the job creator\n        // const job = await prisma.job.findUnique({ where: { id: resourceId } })\n        // return job?.hirerId === userId\n        return true // Placeholder\n      \n      case 'gig':\n        // Check if user is the gig creator\n        // const gig = await prisma.gig.findUnique({ where: { id: resourceId } })\n        // return gig?.freelancerId === userId\n        return true // Placeholder\n      \n      case 'message':\n        // Check if user is sender or receiver\n        // const message = await prisma.message.findUnique({ where: { id: resourceId } })\n        // return message?.senderId === userId || message?.receiverId === userId\n        return true // Placeholder\n      \n      case 'payment':\n        // Check if user is involved in the payment\n        // const payment = await prisma.payment.findUnique({ where: { id: resourceId } })\n        // return payment?.fromUserId === userId || payment?.toUserId === userId\n        return true // Placeholder\n      \n      default:\n        return false\n    }\n  } catch (error) {\n    console.error('Error checking resource ownership:', error)\n    return false\n  }\n}\n\n// Input sanitization helpers\nexport function sanitizeHtml(input: string): string {\n  return input\n    .replace(/<script[^>]*>.*?<\\/script>/gi, '')\n    .replace(/<iframe[^>]*>.*?<\\/iframe>/gi, '')\n    .replace(/<object[^>]*>.*?<\\/object>/gi, '')\n    .replace(/<embed[^>]*>/gi, '')\n    .replace(/javascript:/gi, '')\n    .replace(/on\\w+\\s*=/gi, '')\n}\n\nexport function sanitizeFileName(fileName: string): string {\n  return fileName\n    .replace(/[^a-zA-Z0-9.-]/g, '_')\n    .replace(/\\.{2,}/g, '.')\n    .substring(0, 255)\n}\n\n// IP address extraction\nexport function getClientIP(request: NextRequest): string {\n  const forwarded = request.headers.get('x-forwarded-for')\n  const realIP = request.headers.get('x-real-ip')\n  const cfIP = request.headers.get('cf-connecting-ip')\n  \n  if (forwarded) return forwarded.split(',')[0].trim()\n  if (realIP) return realIP\n  if (cfIP) return cfIP\n  \n  return request.ip || 'unknown'\n}\n\n// CSRF token validation (for forms)\nexport function generateCSRFToken(): string {\n  return crypto.randomUUID()\n}\n\nexport function validateCSRFToken(provided: string, expected: string): boolean {\n  return provided === expected\n}